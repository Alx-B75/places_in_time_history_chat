<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Your Threads — Places in Time</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/static/pit-favicon-mark.ico" sizes="any" />
  <link rel="icon" type="image/png" sizes="192x192" href="/static/icon-192.png" />
  <link rel="manifest" href="/static/site.webmanifest" />
  <meta name="theme-color" content="#0b1020" />
  <link href="/static/style.css?v=brand-7" rel="stylesheet" />
</head>
<body>
  <div class="wrap">
    <div class="banner">
      <div class="brand-side">
        <div class="brand-mark">
          <img src="/static/icon-192.png" alt="Places in Time" />
        </div>
        <div class="brand-title">
          <h1>Places in Time</h1>
          <div class="muted" id="user-label">—</div>
        </div>
      </div>
      <div class="banner-actions">
        <button id="logout-btn" class="btn btn-danger">Log out</button>
      </div>
    </div>

    <div class="grid">
      <aside class="card panel">
        <div class="row" style="margin-bottom:8px;">
          <button id="new-thread-btn" class="btn btn-primary">New Thread</button>
        </div>
        <div id="threads" class="stack"></div>
      </aside>

      <main class="card chat-card">
        <div class="chat-header">
          <div class="controls">
            <input id="thread-title" placeholder="New thread" />
            <button id="save-title-btn" class="btn">Save Title</button>
          </div>

          <div class="figure-hero">
            <img id="figure-hero-img" class="figure-hero-img" src="/static/icon-192.png" alt="">
            <div class="figure-hero-text">
              <div class="figure-row">
                <img id="figure-avatar" class="figure-avatar" alt="" src="/static/icon-192.png">
                <div class="figure-name" id="current-figure">Figure: none</div>
                <div class="figure-select">
                  <label class="muted" for="figure-select" style="margin-right:8px;">Change</label>
                  <select id="figure-select">
                    <option value="">None (generic historian)</option>
                  </select>
                </div>
              </div>
              <p id="figure-desc" class="figure-desc muted"></p>
            </div>
          </div>

          <div id="status" class="status"></div>
        </div>

        <div id="messages" class="messages" aria-live="polite" aria-atomic="false"></div>

        <div id="sources-toggle" class="panel" style="border-top:1px solid var(--border);display:none;padding:8px 16px;">
          <button id="toggle-sources-btn" class="btn sm">Show Sources</button>
          <span id="sources-count" class="muted" style="margin-left:8px"></span>
        </div>
        <div id="sources-panel" class="panel" style="display:none;padding:8px 16px;">
          <div id="sources-list" class="muted"></div>
        </div>

        <form id="message-form" class="compose">
          <textarea id="message-input" rows="3" placeholder="Type a message… (Enter to send, Shift+Enter for a new line)"></textarea>
          <button id="send-btn" type="submit" class="btn">Send</button>
        </form>
      </main>
    </div>
  </div>

  <script>
    function cleanDesc(s) {
      const t = String(s || "").trim();
      if (!t) return "";
      return t
        .replace(/^You are .*?\.\s*/i, "")
        .replace(/^Act as .*?\.\s*/i, "")
        .replace(/\n{2,}/g, "\n")
        .split("\n")[0]
        .trim();
    }
    async function fetchBio(slug) {
      try {
        const r = await fetch(`/figures/${encodeURIComponent(slug)}/bio`);
        if (r.ok) {
          const j = await r.json();
          return cleanDesc(j.description || "");
        }
      } catch (_) {}
      return "";
    }
    function titleCaseSlug(slug){
      if (!slug) return null;
      const romans = new Set(["I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","XV","XVI","XVII","XVIII","XIX","XX"]);
      return slug.split("-").map(part=>{
        const bare = part.replace(/[^a-z0-9]/gi,"");
        const upper = bare.toUpperCase();
        if (romans.has(upper)) return upper + part.slice(bare.length);
        return part.charAt(0).toUpperCase()+part.slice(1);
      }).join(" ").replace(/\s+,/g,",");
    }

    const token = localStorage.getItem('access_token');
    const userId = Number(localStorage.getItem('user_id'));
    const username = localStorage.getItem('username') || '';
    if (!token || !userId) window.location.href = '/';

    const userLabel = document.getElementById('user-label');
    const threadsEl = document.getElementById('threads');
    const messagesEl = document.getElementById('messages');
    const newThreadBtn = document.getElementById('new-thread-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const titleInput = document.getElementById('thread-title');
    const saveTitleBtn = document.getElementById('save-title-btn');
    const figureSelect = document.getElementById('figure-select');
    const currentFigure = document.getElementById('current-figure');
    const figureAvatar = document.getElementById('figure-avatar');
    const figureHeroImg = document.getElementById('figure-hero-img');
    const figureDesc = document.getElementById('figure-desc');
    const statusEl = document.getElementById('status');
    const sourcesToggle = document.getElementById('sources-toggle');
    const sourcesBtn = document.getElementById('toggle-sources-btn');
    const sourcesPanel = document.getElementById('sources-panel');
    const sourcesList = document.getElementById('sources-list');
    const sourcesCount = document.getElementById('sources-count');

    userLabel.textContent = `— signed in as ${username || 'user ' + userId}`;

    let currentThreadId = null;
    const figureCache = Object.create(null);
    let sending = false;

    function authHeaders() { return { 'Authorization': `Bearer ${token}` }; }
    function setStatus(msg, cls){ statusEl.className = 'status' + (cls ? ' ' + cls : ''); statusEl.textContent = msg || ''; }

    async function authGET(url){
      const r=await fetch(url,{headers:authHeaders()});
      if(!r.ok) throw new Error(await r.text());
      return r.json();
    }
    async function authPATCH(url, body){
      const r=await fetch(url,{method:'PATCH',headers:{...authHeaders(),'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!r.ok) throw new Error(await r.text());
      return r.json();
    }
    async function authPOST(url, body){
      const r=await fetch(url,{method:'POST',headers:{...authHeaders(),'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!r.ok) throw new Error(await r.text());
      return r.json();
    }

    async function upgradeGuestIfNeeded() {
      try {
        const r = await fetch('/guest/upgrade', { method: 'POST', headers: authHeaders() });
        if (r.ok) {
          const j = await r.json();
          console.log('Guest upgraded to thread', j.thread_id);
        }
      } catch (_) {}
    }

    async function populateFigureDropdown(){
      try{
        const res = await fetch('/figures/?limit=500');
        if(!res.ok) return;
        const list = await res.json();
        figureSelect.innerHTML='';
        const none=document.createElement('option');
        none.value=''; none.textContent='None (generic historian)';
        figureSelect.appendChild(none);
        list.forEach(f=>{
          if (!f.slug) return;
          figureCache[f.slug] = { name: f.name || f.slug, image_url: f.image_url || "" };
          const opt=document.createElement('option');
          opt.value=f.slug;
          opt.textContent=f.name || f.slug;
          figureSelect.appendChild(opt);
        });
      }catch(_){}
    }

    async function listThreads(){
      const data = await authGET(`/threads/user/${userId}`);
      threadsEl.innerHTML='';
      data.forEach(t=>{
        const el=document.createElement('div');
        el.className='thread-item' + (t.id===currentThreadId ? ' active' : '');
        el.dataset.tid=String(t.id);
        el.textContent = `${t.title || 'Untitled'} ${t.figure_slug ? '· ' + titleCaseSlug(t.figure_slug) : ''}`;
        el.addEventListener('click', ()=> selectThread(t.id));
        threadsEl.appendChild(el);
      });
      if (!currentThreadId && data.length) await selectThread(data[0].id);
    }

    function setFigureHero(info){
      const fallback='/static/icon-192.png';
      const fallback2='/static/logo.png';
      const img = info && info.image_url ? info.image_url : fallback;
      figureHeroImg.src = img;
      figureHeroImg.onerror = function(){ this.onerror=null; this.src=fallback; this.onerror=()=>{ this.src=fallback2; }; };
      figureAvatar.src = img;
      figureAvatar.onerror = function(){ this.onerror=null; this.src=fallback; this.onerror=()=>{ this.src=fallback2; }; };
      currentFigure.textContent = info && info.name ? `Figure: ${info.name}` : 'Figure: none';
    }

    async function loadThreadMeta(threadId){
      const meta = await authGET(`/threads/${threadId}`);
      titleInput.value = meta.title || 'New thread';
      if (meta.figure_slug){
        const slug = meta.figure_slug;
        const bio = await fetchBio(slug);
        const name = (figureCache[slug]?.name) || titleCaseSlug(slug);
        setFigureHero({ name, image_url: figureCache[slug]?.image_url || '' });
        figureDesc.textContent = bio || '';
        figureSelect.value = slug;
      } else {
        setFigureHero(null);
        figureDesc.textContent = '';
        figureSelect.value='';
      }
      return meta;
    }

    function renderMessage(m){
      const div=document.createElement('div');
      div.className = m.role==='user' ? 'msg-user' : 'msg-assistant';
      div.textContent = m.message;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function renderSourcesFromLastAssistant(msgs){
      // Find last assistant message with sources
      let last = null;
      for (let i = msgs.length - 1; i >= 0; i--) {
        const m = msgs[i];
        if (m.role === 'assistant' && m.source_page) { last = m; break; }
      }
      if (!last) { sourcesToggle.style.display='none'; sourcesPanel.style.display='none'; return; }
      try{
        const arr = typeof last.source_page === 'string' ? JSON.parse(last.source_page) : (last.source_page || []);
        if (!Array.isArray(arr) || arr.length === 0) { sourcesToggle.style.display='none'; sourcesPanel.style.display='none'; return; }
        sourcesList.innerHTML = arr.map((s,idx)=>{
          const name = (s.source_name || `Source ${idx+1}`).toString();
          const url = s.source_url || '';
          if (url) return `<div>• <a href="${url}" target="_blank" rel="noopener noreferrer">${escapeHTML(name)}</a></div>`;
          return `<div>• ${escapeHTML(name)}</div>`;
        }).join('');
        sourcesCount.textContent = `(${arr.length})`;
        sourcesToggle.style.display='block';
      } catch(_) {
        sourcesToggle.style.display='none'; sourcesPanel.style.display='none';
      }
    }

    async function renderMessages(){
      if(!currentThreadId) return;
      messagesEl.innerHTML='';
      const msgs = await authGET(`/threads/${currentThreadId}/messages`);
      msgs.forEach(renderMessage);
      renderSourcesFromLastAssistant(msgs);
    }

    async function selectThread(threadId){
      currentThreadId = threadId;
      await loadThreadMeta(threadId);
      await renderMessages();
      Array.from(threadsEl.children).forEach(el=>{
        el.classList.toggle('active', el.dataset.tid === String(threadId));
      });
    }

    async function ensureThread(){
      if (currentThreadId) return currentThreadId;
      const created = await authPOST('/threads', { user_id: userId, title: 'New thread' });
      currentThreadId = created.thread_id;
      await listThreads();
      return currentThreadId;
    }

    async function sendMessage(){
      const text = messageInput.value.trim();
      if (!text || sending) return;
      sending = true; sendBtn.disabled = true;
      try{
        const tid = await ensureThread();
        setStatus('Thinking…');
        const form = new URLSearchParams();
        form.set('user_id', String(userId));
        form.set('message', text);
        form.set('thread_id', String(tid));
        const resp = await fetch('/complete', {
          method: 'POST',
          headers: { ...authHeaders(), 'Content-Type': 'application/x-www-form-urlencoded' },
          body: form.toString()
        });
        if (resp.status !== 303 && resp.status !== 200) throw new Error('Send failed');
        messageInput.value='';
        await renderMessages();
        await listThreads();
        setStatus('');
      } catch(e){
        setStatus('Send failed. Please try again.','err');
      } finally {
        sending = false; sendBtn.disabled = false; messageInput.focus();
      }
    }

    newThreadBtn.addEventListener('click', async ()=>{
      try{
        const created = await authPOST('/threads', { user_id: userId, title: 'New thread' });
        await listThreads();
        await selectThread(created.thread_id);
      } catch(_) {}
    });

    messageForm.addEventListener('submit',(e)=>{ e.preventDefault(); if(e.shiftKey) return; sendMessage(); });
    messageInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); } });

    saveTitleBtn.addEventListener('click', async ()=>{
      if(!currentThreadId) return;
      const newTitle = titleInput.value.trim(); if(!newTitle) return;
      try{
        await authPATCH(`/threads/${currentThreadId}/title`, { title: newTitle });
        await listThreads();
      } catch(_) {}
    });

    figureSelect.addEventListener('change', async ()=>{
      if(!currentThreadId) return;
      const slug = figureSelect.value || null;
      try{
        await authPATCH(`/threads/${currentThreadId}/figure`, { figure_slug: slug });
        if (slug){
          const name = (figureCache[slug]?.name) || titleCaseSlug(slug);
          setFigureHero({ name, image_url: figureCache[slug]?.image_url || '' });
          figureDesc.textContent = await fetchBio(slug);
        } else {
          setFigureHero(null);
          figureDesc.textContent = '';
        }
        await listThreads();
      } catch(_) {}
    });

    logoutBtn.addEventListener('click', ()=>{
      localStorage.removeItem('access_token'); localStorage.removeItem('user_id'); localStorage.removeItem('username');
      window.location.href='/';
    });

    sourcesBtn.addEventListener('click', ()=>{
      const open = sourcesPanel.style.display === 'block';
      sourcesPanel.style.display = open ? 'none' : 'block';
      sourcesBtn.textContent = open ? 'Show Sources' : 'Hide Sources';
    });

    (async function init(){
      await populateFigureDropdown();
      await upgradeGuestIfNeeded();
      await listThreads();
    })();
  </script>
</body>
</html>
