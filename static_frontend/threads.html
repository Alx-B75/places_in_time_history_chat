<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Your Threads — Places in Time</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/static/pit-favicon-mark.ico" sizes="any" />
  <link rel="icon" type="image/png" sizes="192x192" href="/static/icon-192.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16.png" />
  <link rel="apple-touch-icon" href="/static/apple-touch-icon.png" />
  <link rel="manifest" href="/static/site.webmanifest" />
  <meta name="theme-color" content="#0b1020" />
  <link href="/static/style.css?v=brand-7" rel="stylesheet" />
</head>
<body>
  <div class="wrap">
    <div class="banner">
      <div class="brand-side">
        <div class="brand-mark">
          <img src="/static/icon-192.png" alt="Places in Time" />
        </div>
        <div class="brand-title">
          <h1>Places in Time</h1>
          <div class="muted" id="user-label">—</div>
        </div>
      </div>
      <div class="banner-actions">
        <button id="logout-btn" class="btn btn-danger">Log out</button>
      </div>
    </div>

    <div class="grid">
      <aside class="card panel">
        <div class="row" style="margin-bottom:8px;">
          <button id="new-thread-btn" class="btn btn-primary">New Thread</button>
        </div>
        <div id="threads" class="stack"></div>
      </aside>

      <main class="card chat-card">
        <div class="chat-header">
          <div class="controls">
            <input id="thread-title" placeholder="New thread" />
            <button id="save-title-btn" class="btn">Save Title</button>
          </div>

          <div class="figure-hero">
            <img id="figure-hero-img" class="figure-hero-img" src="/static/icon-192.png" alt="">
            <div class="figure-hero-text">
              <div class="figure-row">
                <img id="figure-avatar" class="figure-avatar" alt="" src="/static/icon-192.png">
                <div class="figure-name" id="current-figure">Figure: none</div>
                <div class="figure-select">
                  <label class="muted" for="figure-select" style="margin-right:8px;">Change</label>
                  <select id="figure-select">
                    <option value="">None (generic historian)</option>
                  </select>
                </div>
              </div>
              <p id="figure-desc" class="figure-desc muted"></p>
            </div>
          </div>

          <div id="status" class="status"></div>
        </div>

        <div id="messages" class="messages" aria-live="polite" aria-atomic="false"></div>

        <form id="message-form" class="compose">
          <textarea id="message-input" rows="3" placeholder="Type a message… (Enter to send, Shift+Enter for a new line)"></textarea>
          <button id="send-btn" type="submit" class="btn">Send</button>
        </form>
      </main>
    </div>
  </div>

  <script>
    function cleanDesc(s) {
      const t = String(s || "").trim();
      if (!t) return "";
      return t
        .replace(/^You are .*?\.\s*/i, "")
        .replace(/^Act as .*?\.\s*/i, "")
        .replace(/\n{2,}/g, "\n")
        .split("\n")[0]
        .trim();
    }

    async function fetchBio(slug) {
      try {
        const r = await fetch(`/figures/${encodeURIComponent(slug)}/bio`);
        if (r.ok) {
          const j = await r.json();
          return cleanDesc(j.description || "");
        }
      } catch (_) {}
      return "";
    }

    const token = localStorage.getItem('access_token');
    const userId = Number(localStorage.getItem('user_id'));
    const username = localStorage.getItem('username') || '';
    const urlParams = new URLSearchParams(location.search);
    const figureFromQuery = urlParams.get('figure');

    const userLabel = document.getElementById('user-label');
    const threadsEl = document.getElementById('threads');
    const messagesEl = document.getElementById('messages');
    const newThreadBtn = document.getElementById('new-thread-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const titleInput = document.getElementById('thread-title');
    const saveTitleBtn = document.getElementById('save-title-btn');
    const figureSelect = document.getElementById('figure-select');
    const currentFigure = document.getElementById('current-figure');
    const figureAvatar = document.getElementById('figure-avatar');
    const figureHeroImg = document.getElementById('figure-hero-img');
    const figureDesc = document.getElementById('figure-desc');
    const statusEl = document.getElementById('status');

    if (!token || !userId) window.location.href = '/';
    userLabel.textContent = `— signed in as ${username || 'user ' + userId}`;

    let currentThreadId = null;
    let appliedQueryFigure = false;
    const figureCache = Object.create(null);
    let sending = false;

    function authHeaders() { return { 'Authorization': `Bearer ${token}` }; }
    function setStatus(msg, cls){ statusEl.className = 'status' + (cls ? ' ' + cls : ''); statusEl.textContent = msg || ''; }

    function titleCaseSlug(slug){
      if (!slug) return null;
      const romans = new Set(["I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","XV","XVI","XVII","XVIII","XIX","XX"]);
      return slug.split("-").map(part=>{
        const bare = part.replace(/[^a-z0-9]/gi,"");
        const upper = bare.toUpperCase();
        if (romans.has(upper)) return upper + part.slice(bare.length);
        return part.charAt(0).toUpperCase()+part.slice(1);
      }).join(" ").replace(/\s+,/g,",");
    }

    async function getFigure(slug){
      if (!slug) return null;
      if (figureCache[slug]) return figureCache[slug];
      try{
        const res = await fetch(`/figures/${encodeURIComponent(slug)}`);
        if (res.ok){
          const fig = await res.json();
          const bio = await fetchBio(slug);
          const payload = {
            name: fig.name || titleCaseSlug(slug),
            image_url: fig.image_url || "",
            description: bio || cleanDesc(fig.description || fig.summary || fig.persona_prompt || "")
          };
          figureCache[slug] = payload;
          return payload;
        }
      }catch(_){}
      const fallback = { name: titleCaseSlug(slug), image_url: "", description: "" };
      figureCache[slug] = fallback;
      return fallback;
    }

    async function jsonGET(url){ const r=await fetch(url,{headers:authHeaders()}); if(!r.ok) throw new Error(await r.text()); return r.json(); }
    async function jsonPATCH(url,body){
      const r=await fetch(url,{method:'PATCH',headers:{...authHeaders(),'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!r.ok) throw new Error(await r.text()); return r.json();
    }
    async function jsonPOSTAuth(url,body){
      const r=await fetch(url,{method:'POST',headers:{...authHeaders(),'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!r.ok) throw new Error(await r.text()); return r.json();
    }

    async function populateFigureDropdown(){
      const res = await fetch(`/figures?limit=500`);
      const list = await res.json();
      figureSelect.innerHTML='';
      const none=document.createElement('option'); none.value=''; none.textContent='None (generic historian)'; figureSelect.appendChild(none);
      list.forEach(f=>{
        if(f.slug) figureCache[f.slug] = { name: f.name || f.slug, image_url: f.image_url || "", description: "" };
        const opt=document.createElement('option'); opt.value=f.slug; opt.textContent=f.name || f.slug; figureSelect.appendChild(opt);
      });
    }

    function upsertThreadItem(t){
      const existing = [...threadsEl.children].find(x => x.dataset.tid === String(t.id));
      const el = existing || document.createElement('div');
      el.className = 'thread-item' + (t.id === currentThreadId ? ' active' : '');
      el.dataset.tid = String(t.id);

      const thumb = existing ? el.querySelector('img') : document.createElement('img');
      thumb.className = 'thread-thumb';
      const meta = existing ? el.querySelector('.thread-text') : document.createElement('div');
      meta.className = 'thread-text';
      const title = existing ? el.querySelector('.thread-title') : document.createElement('div');
      title.className = 'thread-title';
      const sub = existing ? el.querySelector('.thread-meta') : document.createElement('div');
      sub.className = 'thread-meta';

      title.textContent = t.title || 'Untitled';
      sub.textContent = `#${t.id}${t.figure_slug ? ' · ' + titleCaseSlug(t.figure_slug) : ''}`;

      const fallback = '/static/icon-192.png';
      const fallback2 = '/static/logo.png';
      const imgUrl = (t.figure_slug && figureCache[t.figure_slug]?.image_url) ? figureCache[t.figure_slug].image_url : fallback;
      thumb.src = imgUrl;
      thumb.onerror = function(){ this.onerror=null; this.src=fallback; this.onerror=()=>{ this.src=fallback2; }; };

      if (!existing){
        meta.appendChild(title); meta.appendChild(sub);
        el.appendChild(thumb); el.appendChild(meta);
        el.addEventListener('click', () => selectThread(t.id));
        threadsEl.appendChild(el);
      } else {
        el.className = 'thread-item' + (t.id === currentThreadId ? ' active' : '');
      }
    }

    async function listThreads(){
      const data=await jsonGET(`/threads/user/${userId}`);
      threadsEl.innerHTML='';
      data.forEach(upsertThreadItem);
      if(!currentThreadId && data.length) await selectThread(data[0].id);
    }

    function setFigureHero(info){
      const fallback = '/static/icon-192.png';
      const fallback2 = '/static/logo.png';
      figureHeroImg.src = info && info.image_url ? info.image_url : fallback;
      figureHeroImg.onerror = function(){ this.onerror=null; this.src=fallback; this.onerror=()=>{ this.src=fallback2; }; };
      figureAvatar.src = info && info.image_url ? info.image_url : fallback;
      figureAvatar.onerror = function(){ this.onerror=null; this.src=fallback; this.onerror=()=>{ this.src=fallback2; }; };
      currentFigure.textContent = info && info.name ? `Figure: ${info.name}` : 'Figure: none';
      figureDesc.textContent = info && info.description ? info.description : '';
    }

    async function loadThreadMeta(threadId){
      const meta=await jsonGET(`/threads/${threadId}`);
      titleInput.value=meta.title || 'New thread';
      if (meta.figure_slug){
        const info = await getFigure(meta.figure_slug);
        setFigureHero(info);
        figureSelect.value=meta.figure_slug || '';
      } else {
        setFigureHero(null);
        figureSelect.value='';
      }
      return meta;
    }

    async function selectThread(threadId){
      currentThreadId=threadId;
      await loadThreadMeta(threadId);

      if(figureFromQuery && !appliedQueryFigure){
        try{
          await jsonPATCH(`/threads/${currentThreadId}/figure`,{figure_slug:figureFromQuery});
          await loadThreadMeta(currentThreadId);
          history.replaceState({},'',window.location.pathname);
        }catch(e){}
        finally{ appliedQueryFigure=true; }
      }

      await renderMessages();
      Array.from(threadsEl.children).forEach(el=>{
        const active=el.dataset.tid === String(threadId);
        el.classList.toggle('active',active);
      });
    }

    function renderMessage(m){
      const div=document.createElement('div');
      div.className=m.role==='user'?'msg-user':'msg-assistant';
      div.textContent=m.message;
      messagesEl.appendChild(div);
      messagesEl.scrollTop=messagesEl.scrollHeight;
    }

    async function renderMessages(){
      if(!currentThreadId) return;
      messagesEl.innerHTML='';
      const msgs=await jsonGET(`/threads/${currentThreadId}/messages`);
      msgs.forEach(renderMessage);
    }

    async function sendMessage(){
      const text=messageInput.value.trim();
      if(!text || !currentThreadId || sending) return;
      try{
        sending=true; sendBtn.disabled=true;
        const meta=await jsonGET(`/threads/${currentThreadId}`);
        const info = meta.figure_slug ? await getFigure(meta.figure_slug) : null;
        const thinker=(info && info.name) || 'The historian';
        setStatus(`${thinker} is thinking…`);
        const form=new URLSearchParams();
        form.set('user_id', String(userId));
        form.set('message', text);
        form.set('thread_id', String(currentThreadId));
        const resp=await fetch('/complete',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:form.toString()});
        if(resp.status!==303 && resp.status!==200) throw new Error('Send failed');
        messageInput.value='';
        await renderMessages();
        setStatus('');
      }catch(err){
        setStatus('Send failed. Please try again.','err');
      }finally{
        sending=false; sendBtn.disabled=false; messageInput.focus();
      }
    }

    newThreadBtn.addEventListener('click', async ()=>{
      try{
        const created=await jsonPOSTAuth('/threads',{user_id:userId,title:'New thread'});
        const newId=created.thread_id; await listThreads(); if(newId) await selectThread(newId);
      }catch(e){}
    });

    messageForm.addEventListener('submit',(e)=>{ e.preventDefault(); sendMessage(); });
    messageInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); } });

    saveTitleBtn.addEventListener('click', async ()=>{
      if(!currentThreadId) return;
      const newTitle=titleInput.value.trim(); if(!newTitle) return;
      try{ await jsonPATCH(`/threads/${currentThreadId}/title`,{title:newTitle}); await listThreads(); }
      catch(e){}
    });

    figureSelect.addEventListener('change', async ()=>{
      if(!currentThreadId) return;
      const slug=figureSelect.value || null;
      try{
        await jsonPATCH(`/threads/${currentThreadId}/figure`,{figure_slug:slug});
        if (slug){
          const info=await getFigure(slug);
          setFigureHero(info);
        } else {
          setFigureHero(null);
        }
        await listThreads();
      }catch(e){}
    });

    logoutBtn.addEventListener('click', ()=>{
      localStorage.removeItem('access_token'); localStorage.removeItem('user_id'); localStorage.removeItem('username');
      window.location.href='/';
    });

    (async function init(){ await populateFigureDropdown(); await listThreads(); })();
  </script>
</body>
</html>
